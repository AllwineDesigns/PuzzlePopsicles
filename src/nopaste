import React, { Component } from 'react';
import seedrandom from 'seedrandom';

import img from './Logo.svg';

const pt2str = ([x,y]) => (x + "," + y);
const lerp = (pt1,pt2,t) => ([pt1[0]*(1-t)+pt2[0]*t, pt1[1]*(1-t)+pt2[1]*t]);
const add = (pt1,pt2) => ([pt1[0]+pt2[0], pt1[1]+pt2[1]]);

const appendEdge = (pts, edge) => {
  if(edge.length === 2) {
    pts.push("L " + pt2str(edge[1]));
  } else {
    pts.push("L " + pt2str(edge[1]));
    pts.push("C " + pt2str(edge[2]) + " " + pt2str(edge[3]) + " " + pt2str(edge[4]));
    pts.push("L " + pt2str(edge[5]));
  }
};

class App extends Component {
  constructor(props) {
    super(props);

    const rng = seedrandom(this.props.seed);
    const crng = (m) => (m*(rng()-.5));

    let w = this.props.piece_width;
    let h = this.props.piece_height;

    this.points = [];

    for(let r = 0; r < this.props.rows+1; r++) {
      let row = [];
      this.points.push(row);
      for(let c = 0; c < this.props.cols+1; c++) {
        let x = c*this.props.piece_width;
        let y = r*this.props.piece_height;
        if(r !== 0 && r !== this.props.rows) {
          y += crng(.25*h);
        }

        if(c !== 0 && c !== this.props.cols) {
          x += crng(.25*w);
        }

        row.push([x,y]);
      }
    }

    this.horizontal_edges = [];
    for(let r = 0; r < this.props.rows+1; r++) {
      let row = [];
      this.horizontal_edges.push(row);
      for(let c = 0; c < this.props.cols; c++) {
        let pt1 = this.points[r][c];
        let pt2 = this.points[r][c+1];

        if(r === 0 || r === this.props.rows) {
          row.push([ pt1, pt2 ]);
        } else {
          const up = 2*Math.floor(2*rng())-1;
          row.push([ pt1, add(lerp(pt1,pt2,.33), [ crng(w*.083), crng(h*.083) ]),
                          add(lerp(pt1,pt2,.167), [ crng(w*.083), up*.33+crng(h*.083) ]),
                          add(lerp(pt1,pt2,.833), [ crng(w*.083), up*.33+crng(h*.083) ]),
                          add(lerp(pt1,pt2,.67), [ crng(w*.083), crng(h*.083) ]),
                          pt2 ]);

        }
      }
    }

    this.vertical_edges = [];
    for(let r = 0; r < this.props.rows; r++) {
      let row = [];
      this.vertical_edges.push(row);
      for(let c = 0; c < this.props.cols+1; c++) {
        let pt1 = this.points[r][c];
        let pt2 = this.points[r+1][c];

        if(c === 0 || c === this.props.cols) {
          row.push([ pt1, pt2 ]);
        } else {
          const left = 2*Math.floor(2*rng())-1;
          row.push([ pt1, add(lerp(pt1,pt2,.33), [ crng(w*.083), crng(h*.083) ]),
                          add(lerp(pt1,pt2,.167), [ left*.33+crng(w*.083), crng(h*.083) ]),
                          add(lerp(pt1,pt2,.833), [ left*.33+crng(w*.083), crng(h*.083) ]),
                          add(lerp(pt1,pt2,.67), [ crng(w*.083), crng(h*.083) ]),
                          pt2 ]);

        }
      }
    }
  }
  render() {
    let strokeWidth = .01;
    let width = this.props.piece_width*this.props.cols+strokeWidth+this.props.margin*2;
    let height = this.props.piece_height*this.props.rows+strokeWidth+this.props.margin*2;
    let img_width = this.props.dpi*width;
    let img_height = this.props.dpi*height;

    let pieces = [];

    for(let r = 0; r < this.props.rows; r++) {
      for(let c = 0; c < this.props.cols; c++) {
        let pts = [];

        var edge1 = this.horizontal_edges[r][c];
        var edge2 = this.vertical_edges[r][c+1];
        var edge3 = this.horizontal_edges[r+1][c].slice().reverse();
        var edge4 = this.vertical_edges[r][c].slice().reverse();

        pts.push("M" + pt2str(edge1[0]));
        appendEdge(pts, edge1)
        appendEdge(pts, edge2)
        appendEdge(pts, edge3)
        appendEdge(pts, edge4)
        pts[pts.length-1] = "Z";

//        pts.push("M " + pt2str(this.points[r][c]));
//        pts.push("L " + pt2str(this.points[r][c+1]));
//        pts.push("L " + pt2str(this.points[r+1][c+1]));
//        pts.push("L " + pt2str(this.points[r+1][c]));
//        pts.push("L " + pt2str(this.points[r][c]));
        pieces.push(<path d={pts.join(" ")} fill="url(#mypattern)" strokeWidth=".01" stroke="black" key={r + "," + c}/>)
      }
    }
    return (
    <div style={{ margin: "30px" }}>
      <svg width={img_width} height={img_height} viewBox={"0 0 " + width + " " + height} xmlns="http://www.w3.org/2000/svg">
        <defs>
          <pattern id="mypattern" width={10} height={10} patternUnits="userSpaceOnUse">
            <polygon points="5,0 10,10 0,10" fill="black"/>
          </pattern>
        </defs>
        <circle cx="1" cy="1" r="1" stroke="black" strokeWidth=".01" fill="url(#mypattern)"/>
        <g transform={"translate(" + (this.props.margin+strokeWidth*.5) + ", " + (this.props.margin+strokeWidth*.5) + ")"}>
          {pieces}
        </g>
      </svg>
<svg width="120" height="120" viewBox="0 0 120 120"
    xmlns="http://www.w3.org/2000/svg">

  <defs>
    <pattern id="Triangle" width="10" height="10"
        patternUnits="userSpaceOnUse">
      <polygon points="5,0 10,10 0,10"/>
	</pattern>
  </defs>

  <circle cx="60" cy="60" r="50" fill="url(#Triangle)"/>
</svg>
    </div>
    );
  }
}

export default App;
